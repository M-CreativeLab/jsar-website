# Babylon.js APIs

![jsar-architecture](jsar-architecture.png)

JSAR 是一套基于 Babylon.js 构建的 WebAR 应用开发框架，因此在 JSAR TypeScript 中，你可以使用大部分 Babylon.js 的应用接口，本文将着重介绍 JSAR 运行时中如何使用，以及可以使用的 Babylon.js APIs。

## 如何使用 Babylon.js APIs

在 JSAR 中使用 [Babylon.js APIs](https://doc.babylonjs.com/typedoc/modules/BABYLON) 非常简单，因为在每个 XSML 文档中，都会默认创建一个 Babylon.js 场景，你可以通过全局变量 `spaceDocument` 获取到它：

```typescript
// 获取 Babylon.js 场景
const scene = spaceDocument.scene as BABYLON.Scene;
```

这样就可以按照 [Babylon.js Scene](https://doc.babylonjs.com/typedoc/classes/BABYLON.Scene) 的接口来使用这个对象了，比如获取到场景下的所有 Mesh：

```typescript
// 获取 Babylon.js 场景
const scene = spaceDocument.scene as BABYLON.Scene;

// 获取场景下的所有 Mesh
const meshes = scene.meshes;
console.log(meshes);
```

除了获取场景外，你可能还需要使用 `BABYLON` 的其他能力，比如创建一个 `BABYLON.Vector3`：

```typescript
// 创建一个 Vector3
const vector3 = new BABYLON.Vector3(1, 2, 3);
console.log(vector3);
```

也可以直接访问 [BABYLON](https://doc.babylonjs.com/typedoc/modules/BABYLON) 这个对象。

## 可使用的 Babylon.js APIs

首先，为什么不是所有的 Babylon.js APIs 都可以使用呢？

这是因为 Babylon.js 是一个基于 WebGL 的 3D 渲染引擎，尽管 Babylon.js 提供了一套自定义 Engine 的机制用于支持不同的渲染实现，但在 JSAR 中由于我们需要基于更加上层的场景对象和 Unity 进行融合，因此无法简单地使用 GPU 指令来实现上层的 Babylon.js APIs，因此在 JSAR 中，我们只能使用 Babylon.js 中的一部分接口，但 JSAR 会一直致力于为 Web 开发者提供一致的开发体验，会努力在未来支持更多的 Babylon.js APIs，并与 Babylon.js 社区讨论如何更好地支持 Babylon.js。

目前，JSAR 支持的 Babylon.js 特性如下：

- [动画系统](https://doc.babylonjs.com/features/featuresDeepDive/animation)
- [网格系统（基础）](https://doc.babylonjs.com/features/featuresDeepDive/mesh)
- [材质系统（基础）](https://doc.babylonjs.com/features/featuresDeepDive/materials)
- [资源系统](https://doc.babylonjs.com/features/featuresDeepDive/importers)
- [事件系统](https://doc.babylonjs.com/features/featuresDeepDive/events)

另外，有一些 API 与可嵌入空间的定位冲突，因此在 JSAR 中无法使用，比如：

- [相机系统](https://doc.babylonjs.com/features/cameras)，由于相机不由 JSAR 控制，因此无法使用 Babylon.js 中的相机系统
- [灯光系统](https://doc.babylonjs.com/features/lights)，由于灯光同样不受 JSAR 控制，因此无法使用 Babylon.js 中的灯光系统

### Babylon.js 动画系统

Babylon.js 动画系统是 Babylon.js 中最重要的一部分，它提供了一套完整的动画系统，但对于 JSAR 来说，只需要将动画处理后的结果（即场景中物体的位置、旋转和缩放）同步到 Unity 渲染侧即可。

比如：

```typescript
// 获取 Babylon.js 场景
const scene = spaceDocument.scene as BABYLON.Scene;

// 获取场景下的所有 Mesh
const meshes = scene.meshes;

// 创建一个动画
const animation = new BABYLON.Animation(
  'myAnimation',
  'position',
  30,
  BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
  BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
);

// 创建一个动画帧
const keys = [];

// 第一帧
keys.push({
  frame: 0,
  value: new BABYLON.Vector3(0, 0, 0),
});

// 第二帧
keys.push({
  frame: 20,
  value: new BABYLON.Vector3(0, 10, 0),
});

// 第三帧
keys.push({
  frame: 100,
  value: new BABYLON.Vector3(0, 0, 0),
});

// 将动画帧添加到动画中
animation.setKeys(keys);

// 将动画添加到 Mesh 上
meshes[0].animations.push(animation);

// 开始动画
scene.beginAnimation(meshes[0], 0, 100, true);
```

或者从一个加载的 Glb 模型中播放第一个动画（如何存在）：

```typescript
// 获取 Babylon.js 场景
const scene = spaceDocument.scene as BABYLON.Scene;

// 获取场景下的所有 Mesh
const meshes = scene.meshes;

// 获取场景下的所有动画
const animationGroups = scene.animationGroups;

// 播放第一个动画组
animationGroups[0].start(true);
```
